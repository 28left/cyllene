import re
import ast

# # Dictionary of possible variables to be instantiated in Stage 1
# stage_1_dict = {
#     'A': re.compile(r'$A = (?P<A>.*)\n'),
#     'AA': re.compile(r'$AA = (?P<AA>.*)\n'),
#     'B': re.compile(r'$B = (?P<B>.*)\n'),
#     'BB': re.compile(r'$BB = (?P<BB>.*)\n'),
#     'C': re.compile(r'$C = (?P<C>.*)\n'),
#     'CC': re.compile(r'$CC = (?P<CC>.*)\n')
# }

# def find_2nd(string, substring):
#    return string.find(substring, string.find(substring) + 1)

# def remove_things(rest):
#     output = rest.replace("$","")
#     if output.find("randnum") > -1:
#         output = output[:find_2nd(output, ",")] + ")"
#         output = output.replace("randnum", "rd.randint")
#     output = output.replace("<s:union>", "\cup")
#     return output

# def clean_up_latex(line):

#     # i = line.find("$")
#     # while i > -1:
#     #     key1 = line[i + 1 : i + 2]
#     #     key2 = line[i + 1 : i + 3]
#     #     key = None
#     #     if key2 in stage_1_dict:
#     #         key = key2
#     #     elif key1 in stage_1_dict:
#     #         key = key1
#     #     if key:
#     #         line = line[:i] + "#{" + key + "}" + line[i + 1 + len(key):]
#     #     i = line.find("$")
#     # line = line.replace("\[", "$$")
#     # line = line.replace("\]", "$$")
#     # line = line.replace("\\frac", "\\dfrac")
#     return line

# def destroy_EQN(line):
#     i = line.find("<EQN")
#     while i > -1:
#         # we've identified that there is an EQN tag present. now have to keep only the insides:
#         contents = line[i + 5 : i + line[i:].find(">")]
#         rest = line[i + line[i:].find(">") + 1 : ]
#         contents = clean_up_latex(contents)
#         line = line[:i] + contents + rest
#         i = line.find("<EQN")
#     return line

# def parse_line_with_dictionary(line, dictionary):
#     """
#     Do a regex search against all defined regexes and
#     return the key and match result of the first matching regex

#     """
#     for key, rx in dictionary.items():
#         match = rx.search(line)
#         if match:
#             print("found match for key: " + str(key))
#             return key, match
#     # if there are no matches
#     return None, None


def remove_watex(string):
    """
    removes <watex> </watex> outer bracket, if present
    """
    pattern = re.compile(r"<watex>((?:.|\n)*?)</watex>$")
    return pattern.sub(r"\1", string)


def convert_array(string):
    """
    Convert a Perl array declaration
        @VAR = (A, B, C)
    to JSON Problem syntax:
        VAR = [A, B, C]
    where A,B,C are either numerical or a string expression
    """

    # if array is generated by 'pick" call, leave it alone, as it will be handled by ProblemDict class
    if re.match("pick\(", string):
        return convert_params(string)

    # replace outer () by [] and try to evaluate as array
    string = "[" + string.strip()[1:-1] + "]"
    string = convert_params(string)

    return string

    # print("Now converting array: " + string)

    # try:
    #     new_array= ast.literal_eval(string)
    # except:
    #     print('Could not convert array')
    #     return None

    # string = string.replace('$', '')
    # string_list = string.split(',')

    # new_array = []

    # print(string_list)

    # # cycle through array entries and convert numerical ones
    # for s in string_list:
    #     if re.match(r'[0-9]*\.?[0-9]+', s.strip()):
    #         new_array.append(ast.literal_eval(s.strip()))
    #     else:
    #         new_array.append(s.strip())

    return new_array


def convert_params(string):

    # # find all <EQN...> and substitute @{.}
    # pattern = re.compile(r'<EQN (.*?)>')
    # new_string = pattern.sub(r'@{\1}', new_string)

    # remove all '$' inside @{...}
    # remove_list = re.findall(r'@\{.*?\}', new_string)
    # for substring in remove_list:
    #     new_string = new_string.replace(substring, substring.replace('$', ''))

    # replace '$' Perl variable prefixes

    # first catch '${...}'
    pattern = re.compile(r"\$\{(\w+)(\[)?\$?(\w+\])?\}")
    string = pattern.sub(r"\1\2\3", string)

    # now simple '$...'
    pattern = re.compile(r"\$(\w+)(\[)?\$?(\w+\])?")
    string = pattern.sub(r"\1\2\3", string)

    return string


def convert_params_string(string):

    # replace '$' Perl variable prefixes by substitution identifier @{.}

    # catch functions ${f(x)} and $f(x)
    pattern = re.compile(r"\$\{(\w+)(\(.+?\))\}")
    string = pattern.sub(r"@{\1\2}", string)

    pattern = re.compile(r"\$(\w+)(\(.+?\))")
    string = pattern.sub(r"@{\1\2}", string)

    # now take care of the other expressions
    pattern = re.compile(r"\$\{(\w+)(\[)?\$?(\w+\])?\}")
    string = pattern.sub(r"@{\1\2\3}", string)

    pattern = re.compile(r"\$(\w+)(\[)?\$?(\w+\])?")
    string = pattern.sub(r"@{\1\2\3}", string)

    return string
    # pattern = re.compile(r'\$\{?(\w+)(\[)?\$?(\w+\])?\}?')
    # return pattern.sub(r'@{\1\2\3}', string)


def convert_eqn_tags(string):
    """
    Convert Perl code WebAssign markers <eqn .> to
    JSON substitution identifiers @{.}
    """
    eqn_list = re.findall(r"<(?:eqn|EQN) .*?>", string)
    replace_list = [convert_params(s) for s in eqn_list]

    for index, s in enumerate(eqn_list):
        string = string.replace(s, replace_list[index])

    pattern = re.compile(r"<(eqn|EQN) (.*?)>")
    string = pattern.sub(r"@{\2}", string)

    # print("after <eqn . > conversion, we have "+string)

    # eqn_list = re.findall(r'<(?:eqn) .*?>', string)
    # replace_list = [convert_params(s) for s in eqn_list]

    # for index, s in enumerate(eqn_list):
    #     string = string.replace(s, replace_list[index])

    # pattern = re.compile(r'<(eqn) (.*?)>')
    # string = pattern.sub(r'@{\2}', string)

    # Now convert tags of the form <eqn>...</eqn>
    eqn_list = re.findall(r"<(?:eqn|EQN)>.*?</(?:eqn|EQN)>", string)
    replace_list = [convert_params(s) for s in eqn_list]

    # print(eqn_list, replace_list)

    for index, s in enumerate(eqn_list):
        string = string.replace(s, replace_list[index])

    pattern = re.compile(r"<(eqn|EQN)>(.*?)</(eqn|EQN)>")
    string = pattern.sub(r"@{\2}", string)

    return string


def convert_string(string):

    # Extract the inner string

    inner_string = ast.literal_eval(string)

    # replace the remaining '$' by '@' format identifiers
    return convert_params(inner_string)


def convert_watex(string):

    # remove <watex> brackets
    string = remove_watex(string)

    # find all <EQN...> and substitute @{.}
    string = convert_eqn_tags(string)

    # now remove all '$' inside @{...}
    # remove_list = re.findall(r'@\{.*?\}', new_string)
    # for substring in remove_list:
    #     new_string = new_string.replace(substring, substring.replace('$', ''))

    # print("After eqn conversion, we have: "+string)

    # convert the Perl variable markers '$'
    string = convert_params_string(string)

    # convert watex specific notation
    string = string.replace("<s:union>", "\\cup")

    # convert '\bf{}' to '<b> </b>'
    pattern = re.compile(r"\\bf\{(.*?)\}")
    string = pattern.sub(r"<b>\1</b>", string)

    # convert '\it{}' to '<i> </i>'
    pattern = re.compile(r"\\it\{(.*?)\}")
    string = pattern.sub(r"<i>\1</i>", string)

    # convert '\uline{}' to '<i> </i>'
    pattern = re.compile(r"\\uline\{(.*?)\}")
    string = pattern.sub(r"<i>\1</i>", string)

    # Escape the remaining '$'
    string = string.replace("$", "\$")

    # # convert <center> \[ ...  \] </center> to display formula $$
    # pattern = re.compile(r"<center>\s*\\\[\s*(.*?)\s*\\\]\s*</center>")
    # string = pattern.sub(r"$$\1$$", string)

    # convert normal '\[ \]' math brackets to '$'
    pattern = re.compile(r"\\\[\s*(.*?)\s*\\\]")
    string = pattern.sub(r"$\1$", string)

    # replace <center> tags
    pattern = re.compile(r"<center>(.*?)</center>")
    string = pattern.sub(r'<p style="text-align:center">\1</p>', string)

    return string


def parse_webassign(parse_string: str, wrap_answers=False):
    stage = 0
    line_no = 0
    json_dict = {}
    json_dict["parameters"] = {}
    solution_found = False

    for line in parse_string.splitlines():

        # remove any part of the line that should be interpreted as a comment
        line = line.partition('#')[0]
        # skip any blank line
        if line.strip() == "":
            continue

        line_no += 1

        # if not line:
        #     print("Empty line!", stage, line_no)
        #     break

        line = line.rstrip()
        # line = line.replace(";", "")

        # Stage 0: initialized
        if stage == 0 and (line == "<eqn>" or line == "<EQN>"):
            command_str = ''
            stage = 1
            # json_dict["parameters"] = { "constants": {}}

        # Stage 1: declaring variables
        elif stage == 1:
            if line == "''</eqn>" or line == "''</EQN>":
                # save command string
                json_dict["parameters"]["code"] = command_str

                stage = 2
            else:
                # collect lines into one string
                command_str += line + '\n'

        # Stage 2: finding first watex prompt (problem statement)
        if stage == 2:
            if re.match("<watex>", line):

                # start gathering statement
                statement = line
                # check whether closing </watex> bracket is in same line
                if re.match("</watex>$", line):
                    # if yes, go to stage 3: Statement processing
                    stage = 3

                else:
                    stage = 2.5

        # Stage 2.5: Find end of problem statement
        elif stage == 2.5:
            statement += line
            if re.match(".*</watex>$", line):
                # if yes, go to stage 3: Statement processing
                stage = 3

        # Stage 3: Parsing the statement
        elif stage == 3:
            # convert statement string Param Problem JSON format
            json_dict["statement"] = convert_watex(statement)

            # go to next stage
            stage = 4

        # Stage 4: Find "Answer" section
        elif stage == 4 and line == "Answer":

            # Found answer
            json_dict["choices"] = []
            stage = 5

        # Stage 5: Convert answer choices
        elif stage == 5:

            if re.match("Solution", line):
                # next up: solution
                solution = ""
                stage = 6
            elif line != "":
                # this line is another answer choice
                answer = convert_watex(line)
                if wrap_answers:
                    answer = "$" + answer + "$"
                json_dict["choices"].append(answer)

        # Stage 6: Find Solution
        elif stage == 6:
            if re.match("<watex>", line):

                # add line to solution
                solution += line
                # check whether closing </watex> bracket is in same line
                if re.match("</watex>$", line):
                    # if yes, go to stage 7: solution processing
                    solution_found = True
                    break

                else:
                    stage = 6.5

        # Stage 6.5: Find end of solution statement
        elif stage == 6.5:
            if line != "":
                solution += line
            if re.match(".*</watex>$", line):
                solution_found = True
                break

    if solution_found:
        json_dict["solution"] = convert_watex(solution)

    return json_dict
